{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Orca 0.5.3-dev0 Orca is a workflow management solution similar in nature to Airflow and Luigi , but specifically for microservices and is built with data streaming in mind. It attempts to provide a sensible way to define a data driven model workflow through a combination of yaml and python. Installation The easiest way to install orca is from pip pip install amanzi.orca To verify that the install succeeded run the version command orca version Quickstart Create a file called orca.yml apiVersion: '1.0' version: '0.1' name: 'quickstart example' job: - task: hello_world python: print('Hello World!') To invoke the CLI after installing one just invokes orca: $ orca Usage: orca [OPTIONS] COMMAND [ARGS]... Options: -v, --verbosity LVL Either CRITICAL, ERROR, WARNING, INFO or DEBUG --help Show this message and exit. Commands: run Run an orca workflow. todot Create a graphviz dot file from an orca workflow. validate Validate an orca workflow. version Print the orca version. Execute the hello world example $ orca run orca.yml Hello World! Concepts This section describes some core concepts to understand how to use orca What is a Orca Workflow ? An orca workflow, is a yaml document describing the actions that make up the workflow. Here is a simple \"hello world\" example apiVersion: '1.0' name: 'hello-workflow' version: 0.1 job: - task: hello python: print('Hello World!') The document above describes a Job object that is an array describing the tasks to perform as steps in the workflow. A task is some action that can be taken during the execution of the workflow, in this instance we are using whats called a python task . There are a number of available tasks available for use in your workflows, They are: python bash http csip You can read more about tasks at their dedicated page . Orca also has the ability to define variables for reuse throughout the workflow. These variables can be reused amongst tasks and passed in as inputs. variables, are namespaced under the var yaml object, and any reference to a variable must being with var. A side note about strings: as you may notice in the example below, for most of our yaml document we have not been quoting our strings the one exception to this rule is in the var section of the document. i.e if the variable is a string you must quote it! apiVersion: '1.0' name: 'variable example' version: '0.1' var: name: 'Susie' job: - task: hello python: | msg = 'Hello {0}'.format(person_to_greet) print(msg) inputs: person_to_greet: var.name Another component of an orca workflow are control structures . Control structures allow for control flow type operations to be performed on a subset of tasks by writing yaml describing the nature of the control flow. There are four kinds of control structures in orca. if control for control switch control fork control If Structures #Example of a if condition object if: 5 > 0 do: - task: cond_task_1 python: print('hello condition!') if structures contain two required top level properties if which describes the condition and do the list of tasks to execute. For structures for: i, range(0,10) do: - task: print_i python: print(counter) inputs: counter: i for control structures also contain two required properties they are : for and do . The value of the for property must be defined as var,expression Switch structures switch: 1 1: - task: start5_1 python: var.afile - task: start5_2 python: var.afile 2: - task: start1_1 python: var.afile - task: start1_2 python: var.afile default: - task: default python: var.afile switch statements require a switch and default properties. The default properties is the set of tasks to run given that the switch condition does not resolve to a case. The switch property value can be be a variable thats evaluated at the time the switch block is reached. Fork structures fork: # first group of tasks - - task: start1 python: var.afile - task: start4 python: var.afile # second group - - task: start2 python: var.afile # third group - - task: start3 python: var.afile A Fork structure is an array, of task lists. each list in the topmost array is executed in parallel. Examples Here is a git repository of examples for using orca Commands Orca currently provides a concise set of commands for running workflows. run The run command executes the workflow defined in the yaml configuration file. Options include ledgers, to publish the results of each task in the workflow too, options include a json, mongo or kafka ledger Usage: orca run [OPTIONS] FILE [ARGS]... Run an orca workflow. Options: --ledger-json PATH file ledger. --ledger-mongo TEXT mongodb ledger, TEXT format \"<host[:port]>/<db>/<col>\". --ledger-kafka TEXT kafka ledger, TEXT format \"<host[:port]>/topic\". --help Show this message and exit. todot Converts the yaml definition into a graphviz dotfile version Prints the current orca version $ orca version 0.5.2","title":"Home"},{"location":"#orca-053-dev0","text":"Orca is a workflow management solution similar in nature to Airflow and Luigi , but specifically for microservices and is built with data streaming in mind. It attempts to provide a sensible way to define a data driven model workflow through a combination of yaml and python.","title":"Orca 0.5.3-dev0"},{"location":"#installation","text":"The easiest way to install orca is from pip pip install amanzi.orca To verify that the install succeeded run the version command orca version","title":"Installation"},{"location":"#quickstart","text":"Create a file called orca.yml apiVersion: '1.0' version: '0.1' name: 'quickstart example' job: - task: hello_world python: print('Hello World!') To invoke the CLI after installing one just invokes orca: $ orca Usage: orca [OPTIONS] COMMAND [ARGS]... Options: -v, --verbosity LVL Either CRITICAL, ERROR, WARNING, INFO or DEBUG --help Show this message and exit. Commands: run Run an orca workflow. todot Create a graphviz dot file from an orca workflow. validate Validate an orca workflow. version Print the orca version. Execute the hello world example $ orca run orca.yml Hello World!","title":"Quickstart"},{"location":"#concepts","text":"This section describes some core concepts to understand how to use orca","title":"Concepts"},{"location":"#what-is-a-orca-workflow","text":"An orca workflow, is a yaml document describing the actions that make up the workflow. Here is a simple \"hello world\" example apiVersion: '1.0' name: 'hello-workflow' version: 0.1 job: - task: hello python: print('Hello World!') The document above describes a Job object that is an array describing the tasks to perform as steps in the workflow. A task is some action that can be taken during the execution of the workflow, in this instance we are using whats called a python task . There are a number of available tasks available for use in your workflows, They are: python bash http csip You can read more about tasks at their dedicated page . Orca also has the ability to define variables for reuse throughout the workflow. These variables can be reused amongst tasks and passed in as inputs. variables, are namespaced under the var yaml object, and any reference to a variable must being with var. A side note about strings: as you may notice in the example below, for most of our yaml document we have not been quoting our strings the one exception to this rule is in the var section of the document. i.e if the variable is a string you must quote it! apiVersion: '1.0' name: 'variable example' version: '0.1' var: name: 'Susie' job: - task: hello python: | msg = 'Hello {0}'.format(person_to_greet) print(msg) inputs: person_to_greet: var.name Another component of an orca workflow are control structures . Control structures allow for control flow type operations to be performed on a subset of tasks by writing yaml describing the nature of the control flow. There are four kinds of control structures in orca. if control for control switch control fork control","title":"What is a Orca Workflow ?"},{"location":"#if-structures","text":"#Example of a if condition object if: 5 > 0 do: - task: cond_task_1 python: print('hello condition!') if structures contain two required top level properties if which describes the condition and do the list of tasks to execute.","title":"If Structures"},{"location":"#for-structures","text":"for: i, range(0,10) do: - task: print_i python: print(counter) inputs: counter: i for control structures also contain two required properties they are : for and do . The value of the for property must be defined as var,expression","title":"For structures"},{"location":"#switch-structures","text":"switch: 1 1: - task: start5_1 python: var.afile - task: start5_2 python: var.afile 2: - task: start1_1 python: var.afile - task: start1_2 python: var.afile default: - task: default python: var.afile switch statements require a switch and default properties. The default properties is the set of tasks to run given that the switch condition does not resolve to a case. The switch property value can be be a variable thats evaluated at the time the switch block is reached.","title":"Switch structures"},{"location":"#fork-structures","text":"fork: # first group of tasks - - task: start1 python: var.afile - task: start4 python: var.afile # second group - - task: start2 python: var.afile # third group - - task: start3 python: var.afile A Fork structure is an array, of task lists. each list in the topmost array is executed in parallel.","title":"Fork structures"},{"location":"#examples","text":"Here is a git repository of examples for using orca","title":"Examples"},{"location":"#commands","text":"Orca currently provides a concise set of commands for running workflows.","title":"Commands"},{"location":"#run","text":"The run command executes the workflow defined in the yaml configuration file. Options include ledgers, to publish the results of each task in the workflow too, options include a json, mongo or kafka ledger Usage: orca run [OPTIONS] FILE [ARGS]... Run an orca workflow. Options: --ledger-json PATH file ledger. --ledger-mongo TEXT mongodb ledger, TEXT format \"<host[:port]>/<db>/<col>\". --ledger-kafka TEXT kafka ledger, TEXT format \"<host[:port]>/topic\". --help Show this message and exit.","title":"run"},{"location":"#todot","text":"Converts the yaml definition into a graphviz dotfile","title":"todot"},{"location":"#version","text":"Prints the current orca version $ orca version 0.5.2","title":"version"},{"location":"tasks/","text":"Tasks Tasks are an abstraction that represent some action to take at workflow execution time. Some examples are: call a service insert data into a database do some transformation on a dataset scrape a webpage Task Types There are four types of tasks currently supported: python bash csip http Task Structure A task has a common list of properties and structure amongst all the different types: Property Description Type Required task The task name, must be unique and a valid identifier (i.e. no spaces) string Y python Either an inline python string, or a path to a python file string At least one kind is required bash Either an inline bash string, or a path to a shell string At least one kind is required http a http url to make a request against, can be to a rest api, or just a normal website string At least one kind is required csip A url to a csip service string At least one kind is required inputs a object describing inputs to call the task with, the values can reference from other tasks or workflow variables object N outputs a list of outputs to capture from the tasks execution string array N config an optional configuration object, its available properties depend on the kind of task object N Referencing Task data later in the workflow Each orca task once completed persists its state for reuse later. apiVersion: '1.0' version: '0.1' name: referencing task outputs job: - task: get_today python: | import datetime today = datetime.datetime.utcnow() outputs: - today - task: print_today python: print(today) inputs: today: task.get_today.today In this example we are referencing the output specified by the get_today task by the string task.get_today.today Task state is namespaced under the task. directive and each tasks data is namespaced further under the task name. Python Task A python task is flexible and can be used in a number of different ways to suit different needs, these are: inline python external script * external module with function calls Inline python example This is the example we are familiar with at this point: task: get_today python: | import datetime today = datetime.datetime.utcnow() outputs: - today Here we are just writing our python inline to the task, this can be useful for very simple things but for more complex tasks, its recommended to either use a external script or a module to complete your python needs. Here we can retrieve the today variable for use later in our workflow, just like we would be able to if we were writing all of this in a normal python script External python script example External scripts are useful for when you want to perform some action that does not have any inputs (right now external scripts do not support injecting inputs, but we are actively working to change this) given the python file scrape.py import bs4 import requests import datetime today = datetime.datetime.utcnow() forecast = 0 file = 'nwm.t{0}z.short_range.channel_rt' url = 'https://nomads.ncep.noaa.gov/pub/data/nccf/com/nwm/prod/nwm.{0}/short_range/' formatted_url = url.format(today.strftime(\"%Y%m%d\")) html = requests.get(formatted_url, headers={'Content-Type': 'text/plain'}).content soup = bs4.BeautifulSoup(html, 'html.parser') a_tags = soup.find_all('a') fmt_file = file.format(str(forecast).zfill(2)) find_file = lambda f: f.get_text().startswith(fmt_file) file_exists = len ( list ( filter ( find_file, a_tags ) ) ) > 0 print('file {0} is present ? = {1}'.format(fmt_file, file_exists)) apiVersion: '1.0' version: '0.1' name: 'scrape nomads for netcdf file' job: - task: scrape python: ./scrape.py outputs: - file_exists - if: task.scrape.file_exists do: - ... External python modules Another way to use the python task is to reference a python module and directly access functions in the module. To do this you must utilize a special configuration for the python task using the config object. The python config object has the following properties available property description type required callable The python function in the module to call string Y returns A name to assign the return value of the callable string Y Lets rewrite the example above to a module, and see how orca can utilize it scrape.py import bs4 import requests def get_html(url, today): formatted_url = url.format(today.strftime(\"%Y%m%d\")) return requests.get(formatted_url, headers={'Content-Type': 'text/plain'}).content def scrape_html(url, today, forecast, file): html = get_html(url, today) soup = bs4.BeautifulSoup(html, 'html.parser') a_tags = soup.find_all('a') fmt_file = file.format(str(forecast).zfill(2)) find_file = lambda f: f.get_text().startswith(fmt_file) file_exists = len ( list ( filter ( find_file, a_tags ) ) ) > 0 print('file {0} is present ? = {1}'.format(fmt_file, file_exists)) return file_exists apiVersion: '1.0' version: '0.1' name: 'check if netcdf file exists for current hour' var: forecast: 0 nomadsUrl: 'https://nomads.ncep.noaa.gov/pub/data/nccf/com/nwm/prod/nwm.{0}/short_range/' fileName: 'nwm.t{0}z.short_range.channel_rt' job: - task: get_today python: | import datetime today = datetime.datetime.utcnow() - task: scrape python: ./scrape.py config: callable: scrape_html returns: current_file_exists inputs: url: var.nomadsUrl today: task.get_today.today forecast: var.forecast file: var.fileName outputs: - current_file_exists - if: current_file_exists do: - ..... In this example we introduced a config object that specifies which function to call, and maps the inputs defined on the task to the inputs defined in the callable function. Additionally we specified a name for the return value, this name can be any valid identifier. If the function returns nothing then returns is not required","title":"Tasks"},{"location":"tasks/#tasks","text":"Tasks are an abstraction that represent some action to take at workflow execution time. Some examples are: call a service insert data into a database do some transformation on a dataset scrape a webpage","title":"Tasks"},{"location":"tasks/#task-types","text":"There are four types of tasks currently supported: python bash csip http","title":"Task Types"},{"location":"tasks/#task-structure","text":"A task has a common list of properties and structure amongst all the different types: Property Description Type Required task The task name, must be unique and a valid identifier (i.e. no spaces) string Y python Either an inline python string, or a path to a python file string At least one kind is required bash Either an inline bash string, or a path to a shell string At least one kind is required http a http url to make a request against, can be to a rest api, or just a normal website string At least one kind is required csip A url to a csip service string At least one kind is required inputs a object describing inputs to call the task with, the values can reference from other tasks or workflow variables object N outputs a list of outputs to capture from the tasks execution string array N config an optional configuration object, its available properties depend on the kind of task object N","title":"Task Structure"},{"location":"tasks/#referencing-task-data-later-in-the-workflow","text":"Each orca task once completed persists its state for reuse later. apiVersion: '1.0' version: '0.1' name: referencing task outputs job: - task: get_today python: | import datetime today = datetime.datetime.utcnow() outputs: - today - task: print_today python: print(today) inputs: today: task.get_today.today In this example we are referencing the output specified by the get_today task by the string task.get_today.today Task state is namespaced under the task. directive and each tasks data is namespaced further under the task name.","title":"Referencing Task data later in the workflow"},{"location":"tasks/#python-task","text":"A python task is flexible and can be used in a number of different ways to suit different needs, these are: inline python external script * external module with function calls","title":"Python Task"},{"location":"tasks/#inline-python-example","text":"This is the example we are familiar with at this point: task: get_today python: | import datetime today = datetime.datetime.utcnow() outputs: - today Here we are just writing our python inline to the task, this can be useful for very simple things but for more complex tasks, its recommended to either use a external script or a module to complete your python needs. Here we can retrieve the today variable for use later in our workflow, just like we would be able to if we were writing all of this in a normal python script","title":"Inline python example"},{"location":"tasks/#external-python-script-example","text":"External scripts are useful for when you want to perform some action that does not have any inputs (right now external scripts do not support injecting inputs, but we are actively working to change this) given the python file scrape.py import bs4 import requests import datetime today = datetime.datetime.utcnow() forecast = 0 file = 'nwm.t{0}z.short_range.channel_rt' url = 'https://nomads.ncep.noaa.gov/pub/data/nccf/com/nwm/prod/nwm.{0}/short_range/' formatted_url = url.format(today.strftime(\"%Y%m%d\")) html = requests.get(formatted_url, headers={'Content-Type': 'text/plain'}).content soup = bs4.BeautifulSoup(html, 'html.parser') a_tags = soup.find_all('a') fmt_file = file.format(str(forecast).zfill(2)) find_file = lambda f: f.get_text().startswith(fmt_file) file_exists = len ( list ( filter ( find_file, a_tags ) ) ) > 0 print('file {0} is present ? = {1}'.format(fmt_file, file_exists)) apiVersion: '1.0' version: '0.1' name: 'scrape nomads for netcdf file' job: - task: scrape python: ./scrape.py outputs: - file_exists - if: task.scrape.file_exists do: - ...","title":"External python script example"},{"location":"tasks/#external-python-modules","text":"Another way to use the python task is to reference a python module and directly access functions in the module. To do this you must utilize a special configuration for the python task using the config object. The python config object has the following properties available property description type required callable The python function in the module to call string Y returns A name to assign the return value of the callable string Y Lets rewrite the example above to a module, and see how orca can utilize it scrape.py import bs4 import requests def get_html(url, today): formatted_url = url.format(today.strftime(\"%Y%m%d\")) return requests.get(formatted_url, headers={'Content-Type': 'text/plain'}).content def scrape_html(url, today, forecast, file): html = get_html(url, today) soup = bs4.BeautifulSoup(html, 'html.parser') a_tags = soup.find_all('a') fmt_file = file.format(str(forecast).zfill(2)) find_file = lambda f: f.get_text().startswith(fmt_file) file_exists = len ( list ( filter ( find_file, a_tags ) ) ) > 0 print('file {0} is present ? = {1}'.format(fmt_file, file_exists)) return file_exists apiVersion: '1.0' version: '0.1' name: 'check if netcdf file exists for current hour' var: forecast: 0 nomadsUrl: 'https://nomads.ncep.noaa.gov/pub/data/nccf/com/nwm/prod/nwm.{0}/short_range/' fileName: 'nwm.t{0}z.short_range.channel_rt' job: - task: get_today python: | import datetime today = datetime.datetime.utcnow() - task: scrape python: ./scrape.py config: callable: scrape_html returns: current_file_exists inputs: url: var.nomadsUrl today: task.get_today.today forecast: var.forecast file: var.fileName outputs: - current_file_exists - if: current_file_exists do: - ..... In this example we introduced a config object that specifies which function to call, and maps the inputs defined on the task to the inputs defined in the callable function. Additionally we specified a name for the return value, this name can be any valid identifier. If the function returns nothing then returns is not required","title":"External python modules"}]}